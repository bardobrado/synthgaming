{"version":3,"file":"timeline.js","sourceRoot":"","sources":["../../../src/timeline/timeline.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,aAAa,EAAE,cAAc,EAAE,MAAM,0CAA0C,CAAC;AAEzF,OAAO,EAAE,OAAO,EAAE,MAAM,4CAA4C,CAAC;AACrE,OAAO,EAAE,SAAS,EAAE,MAAM,mCAAmC,CAAC;AAC9D,OAAO,EAAE,MAAM,EAAE,MAAM,6BAA6B,CAAC;AACrD,OAAO,EAAE,MAAM,EAAE,MAAM,mCAAmC,CAAC;AAE3D,OAAO,EAAE,mBAAmB,EAAE,MAAM,UAAU,CAAC;AAE/C,OAAO,EAAE,WAAW,EAAE,MAAM,6BAA6B,CAAC;AAC1D,OAAO,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AAoCpE;;;;;;;;GAQG;AACH,MAAM,OAAO,QAAS,SAAQ,WAAW;IAuBrC;;;OAGG;IACH,IAAW,aAAa;QACpB,OAAO,IAAI,CAAC,cAAc,CAAC;IAC/B,CAAC;IAED;;;OAGG;IACH,IAAW,eAAe;QACtB,OAAO,IAAI,CAAC,gBAAgB,CAAC;IACjC,CAAC;IAED;;OAEG;IACH,IAAW,eAAe;QACtB,OAAO,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,gBAAgB,CAAC;IACvD,CAAC;IAED;;OAEG;IACH,IAAW,WAAW;QAClB,OAAO,IAAI,CAAC,YAAY,CAAC;IAC7B,CAAC;IAED;;OAEG;IACH,IAAW,cAAc;QACrB,OAAO,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,gBAAgB,CAAC;IACrD,CAAC;IAED;;OAEG;IACH,IAAW,gBAAgB;QACvB,OAAO,IAAI,CAAC,iBAAiB,CAAC;IAClC,CAAC;IAED;;;OAGG;IACH,IAAW,eAAe;QACtB,OAAO,IAAI,CAAC,gBAAgB,CAAC;IACjC,CAAC;IAED;;;;OAIG;IACH,IAAW,iBAAiB;QACxB,OAAO,IAAI,CAAC,kBAAkB,CAAC;IACnC,CAAC;IAED;;;;;;;OAOG;IACH,YAAY,MAAgD,EAAE,OAAyB;QACnF,KAAK,CAAC,MAAM,CAAC,CAAC;QAEd,oCAAoC;QACpC,IAAI,OAAO,CAAC,mCAAmC,KAAK,SAAS,EAAE;YAC3D,OAAO,CAAC,mCAAmC,GAAG,IAAI,CAAC;SACtD;QACD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QAExB,sBAAsB;QACtB,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5B,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3B,IAAI,CAAC,mBAAmB,EAAE,CAAC;IAC/B,CAAC;IAED;;;OAGG;IACI,aAAa,CAAC,QAAqB;QACtC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAC1B,kFAAkF;QAClF,8DAA8D;QAC9D,IAAI,CAAC,eAAe,GAAG,GAAG,EAAE;YACxB,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC1B,CAAC,CAAC;QAEF,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;IACpD,CAAC;IAED;;OAEG;IACI,cAAc;QACjB,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;IACrD,CAAC;IAED;;;;;OAKG;IACI,YAAY,CAAC,WAAwE,EAAE,IAAY;QACtG,6DAA6D;QAC7D,IAAI,SAAS,GAAG,gBAAgB,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,EAAE,EAAE,GAAG,IAAI,CAAC,CAAC;QAEtE,kBAAkB;QAClB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC;QAEnC,OAAO,SAAS,CAAC;IACrB,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,QAAqB;QAC/B,QAAQ,IAAI,QAAQ,EAAE,CAAC;QAEvB,oDAAoD;QACpD,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACrB,OAAO;SACV;QAED,kDAAkD;QAClD,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,EAAE;YACnC,OAAO;SACV;QAED,oCAAoC;QACpC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE;YACvC,OAAO;SACV;QAED,+CAA+C;QAC/C,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;QAE3B,wCAAwC;QACxC,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAE7D,4DAA4D;QAC5D,MAAM,cAAc,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC;QAClE,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,GAAG,IAAI,CAAC,iBAAiB,CAAC;QAEtE,sDAAsD;QACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,kBAAkB,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;YAClD,MAAM,IAAI,GAAG,SAAS,GAAG,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;YAEpD,qDAAqD;YACrD,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;YACnD,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,UAAU,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;YAE5D,4EAA4E;YAC5E,oDAAoD;YACpD,mCAAmC;YACnC,MAAM,WAAW,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,gBAAgB,GAAG,CAAC,GAAG,CAAC,CAAC;YAC/E,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,EAAE,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;YAChF,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;YAEnF,uDAAuD;YACvD,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC;SAC/B;IACL,CAAC;IAED;;;;OAIG;IACI,cAAc,CAAC,IAAY;QAC9B,6EAA6E;QAC7E,qEAAqE;QACrE,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;QAChE,yBAAyB;QACzB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;IAC9B,CAAC;IAED;;;;;;OAMG;IACI,kBAAkB,CAAC,eAAuB;QAC7C,wEAAwE;QACxE,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;QACpD,sIAAsI;QACtI,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;QAE1G,6FAA6F;QAC7F,+BAA+B;QAC/B,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,gBAAgB,CAAC;QACrE,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,kBAAkB,CAAC;QAEzE,iEAAiE;QACjE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAEvC,OAAO,IAAI,CAAC,gBAAgB,CAAC;IACjC,CAAC;IAED;;;;;;OAMG;IACI,sBAAsB,CAAC,OAAe;QACzC,0EAA0E;QAC1E,iCAAiC;QACjC,IAAI,cAAc,GAAG,IAAI,CAAC,kBAAkB,GAAG,CAAC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,OAAO,GAAG,GAAG,CAAC;QAC/G,OAAO,IAAI,CAAC,kBAAkB,CAAC,cAAc,CAAC,CAAC;IACnD,CAAC;IAED;;;;;OAKG;IACI,MAAM;QACT,wBAAwB;QACxB,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;QACrB,8CAA8C;QAC9C,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,CAAC;QACnC,qEAAqE;QACrE,IAAI,CAAC,kCAAkC,EAAE,CAAC;IAC9C,CAAC;IAED;;OAEG;IACI,OAAO;QACV,oBAAoB;QACpB,KAAK,IAAI,cAAc,IAAI,IAAI,CAAC,WAAW,EAAE;YACzC,IAAI,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,cAAc,CAAC,EAAE;gBACjD,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC,OAAO,EAAE,CAAC;aAC9C;SACJ;QAED,gCAAgC;QAChC,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,CAAC;QACjC,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC;QAC9B,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC;QAC/B,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;QAE5B,KAAK,CAAC,OAAO,EAAE,CAAC;IACpB,CAAC;IAEO,oBAAoB;QACxB,cAAc;QACd,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;QAEtB,qDAAqD;QACrD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC;QAC/D,IAAI,IAAI,CAAC,cAAc,KAAK,CAAC,EAAE;YAC3B,MAAM,CAAC,KAAK,CAAC,8DAA8D,CAAC,CAAC;YAC7E,OAAO;SACV;QAED,yCAAyC;QACzC,IAAI,CAAC,kCAAkC,EAAE,CAAC;IAC9C,CAAC;IAEO,kCAAkC;QACtC,mFAAmF;QACnF,8CAA8C;QAC9C,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;QAE5F,wEAAwE;QACxE,0CAA0C;QAC1C,gEAAgE;QAChE,4BAA4B;QAC5B,IAAI,CAAC,WAAW,GAAG,CAAC,GAAG,IAAI,CAAC,kBAAkB,GAAG,CAAC,CAAC;QAEnD,iEAAiE;QACjE,0CAA0C;QAC1C,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,eAAe,GAAG,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC;QAC3E,MAAM,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC;QACnE,MAAM,eAAe,GAAG,cAAc,GAAG,KAAK,CAAC;QAC/C,gEAAgE;QAChE,4BAA4B;QAC5B,IAAI,CAAC,YAAY,GAAG,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;QAE7D,8EAA8E;QAC9E,cAAc;QACd,kEAAkE;QAClE,oEAAoE;QACpE,mCAAmC;QACnC,sDAAsD;QACtD,IAAI,CAAC,aAAa,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,eAAe,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;QAErF,uEAAuE;QACvE,mBAAmB;QACnB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,gBAAgB,IAAI,IAAI,CAAC,kBAAkB,CAAC,CAAC;IAC9E,CAAC;IAEO,mBAAmB;QACvB,kCAAkC;QAClC,IAAI,CAAC,iBAAiB,GAAG,IAAI,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,iBAAiB,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,SAAS,CAAC,6BAA6B,CAAC,CAAC;QACxI,4BAA4B;QAC5B,IAAI,CAAC,WAAW,GAAG,EAAG,CAAC;IAC3B,CAAC;IAEO,mBAAmB;QACvB,gFAAgF;QAChF,IAAI,CAAC,eAAe,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE;YACnD,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YACnC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;SAC9B,CAAC,CAAC;QAEH,8DAA8D;QAC9D,IAAI,CAAC,cAAc,GAAG,IAAI,aAAa,CAAC;YACpC,MAAM,EAAE,IAAI,CAAC,MAAM;YACnB,GAAG,mBAAmB;SACzB,CAAC,CAAC;QAEH,oDAAoD;QACpD,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,CAAC;IACvC,CAAC;IAEO,WAAW,CAAC,IAAY;QAC5B,mDAAmD;QACnD,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAExB,6CAA6C;QAC7C,IAAI,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACvC,IAAI,CAAC,SAAS,EAAE;YACZ,6CAA6C;YAC7C,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;YAC7D,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;SACpD;QAED,+CAA+C;QAC/C,IAAI,SAAS,CAAC,OAAO,EAAE,EAAE;YACrB,OAAO,SAAS,CAAC;SACpB;QAED,uDAAuD;QACvD,wEAAwE;QACxE,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAE1B,iCAAiC;QACjC,OAAO,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;IAC3C,CAAC;IAEO,oBAAoB,CAAC,IAAY;QACrC,gEAAgE;QAChE,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,mCAAmC,EAAE;YACpD,OAAO,IAAI,CAAC,iBAAiB,CAAC;SACjC;QAED,kDAAkD;QAClD,MAAM,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,cAAc,GAAG,IAAI,EAAE,IAAI,CAAC,CAAC;QACnE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,eAAe,EAAE,CAAC,EAAE,EAAE;YACvC,MAAM,MAAM,GAAG,IAAI,GAAG,CAAC,CAAC;YACxB,IAAI,MAAM,GAAG,CAAC,EAAE;gBACZ,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;gBAC3C,IAAI,SAAS,IAAI,SAAS,CAAC,OAAO,EAAE,EAAE;oBAClC,OAAO,SAAS,CAAC;iBACpB;aACJ;YAED,MAAM,KAAK,GAAG,IAAI,GAAG,CAAC,CAAC;YACvB,IAAI,KAAK,GAAG,IAAI,CAAC,aAAa,EAAE;gBAC5B,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;gBAC1C,IAAI,SAAS,IAAI,SAAS,CAAC,OAAO,EAAE,EAAE;oBAClC,OAAO,SAAS,CAAC;iBACpB;aACJ;SACJ;QAED,8BAA8B;QAC9B,OAAO,IAAI,CAAC,iBAAiB,CAAC;IAClC,CAAC;CACJ","sourcesContent":["import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { EffectWrapper, EffectRenderer } from \"@babylonjs/core/Materials/effectRenderer\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { Constants } from \"@babylonjs/core/Engines/constants\";\r\nimport { Logger } from \"@babylonjs/core/Misc/logger\";\r\nimport { Scalar } from \"@babylonjs/core/Maths/math.scalar\";\r\n\r\nimport { ShaderConfiguration } from \"./shader\";\r\n\r\nimport { BaseControl } from \"../coreControls/baseControl\";\r\nimport { elementToTexture } from \"../coreControls/elementToTexture\";\r\n\r\n/**\r\n * Defines a set of options provided to the timeline.\r\n */\r\nexport interface ITimelineOptions {\r\n    /**\r\n     * Defines the total length of the video. This helps computing where we are in the video.\r\n     */\r\n    totalDuration: number;\r\n    /**\r\n     * The width of the thumbnails.\r\n     */\r\n    thumbnailWidth: number;\r\n    /**\r\n     * The height of the thumbnails.\r\n     */\r\n    thumbnailHeight: number;\r\n    /**\r\n     * Defines the URI of loding texture used to replace thumbnail during loading.\r\n     */\r\n    loadingTextureURI: string;\r\n    /**\r\n     * Callback to implement to provide back the required picture info.\r\n     * \r\n     * This will be regularly called for each needed thumbnail by specifying the time\r\n     * of the required picture. It can return either a texture, a video, a canvas or a url.\r\n     */\r\n    getThumbnailCallback: (time: number) => BaseTexture | HTMLCanvasElement | HTMLVideoElement | string;\r\n    /**\r\n     * Defines whether the closest existing/loaded thumbnail should be use in place of the loading texture.\r\n     * True by default.\r\n     */\r\n    useClosestThumbnailAsLoadingTexture?: boolean;\r\n}\r\n\r\n/**\r\n * Represents a timeline: a list of thumbnails for a video.\r\n * The thumbnails are evenly distributed along the visible duration from the video\r\n * The smallest granularity is the second to ensure that 128 width thumbnails would fit\r\n * in memory for a 1 hour long video.\r\n * \r\n * Thumbnail generation is out of scope of the control. They are the responsibility of the client code\r\n * which can dynamically generate or pre generate them on a server.\r\n */\r\nexport class Timeline extends BaseControl {\r\n    private readonly _options: ITimelineOptions;\r\n\r\n    private _effectRenderer: EffectRenderer;\r\n    private _effectWrapper: EffectWrapper;\r\n    private _loadingThumbnail: Texture;\r\n    private _thumbnails: { [timespan: number]: BaseTexture };\r\n\r\n    private _totalThumbnails: number;\r\n    private _visibleThumbnails: number;\r\n\r\n    private _totalDuration: number;\r\n    private _visibleDuration: number;\r\n    private _currentTime: number;\r\n    private _intervalDuration: number;\r\n\r\n    private _widthScale: number;\r\n    private _heightScale: number;\r\n    private _heightOffset: number;\r\n\r\n    private _shouldRender: boolean;\r\n    private _renderFunction: () => void;\r\n\r\n    /**\r\n     * Gets the total duration of the video the canvas has been configured to \r\n     * represent.\r\n     */\r\n    public get totalDuration(): number {\r\n        return this._totalDuration;\r\n    }\r\n\r\n    /**\r\n     * Gets the visible duration the timeline canvas can display without scrolling.\r\n     * It depends on the total number of thumbnails configured.\r\n     */\r\n    public get visibleDuration(): number {\r\n        return this._visibleDuration;\r\n    }\r\n\r\n    /**\r\n     * Gets the max value that can be set as currentTime.\r\n     */\r\n    public get maxSettableTime(): number {\r\n        return this._totalDuration - this._visibleDuration;\r\n    }\r\n\r\n    /**\r\n     * Gets the current start time of the visible part of the timeline.\r\n     */\r\n    public get currentTime(): number {\r\n        return this._currentTime;\r\n    }\r\n\r\n    /**\r\n     * Gets the current end time of the visible part of the timeline.\r\n     */\r\n    public get endVisibleTime(): number {\r\n        return this._currentTime + this._visibleDuration;\r\n    }\r\n\r\n    /**\r\n     * Gets the current duration of the interval between two consecutive thumbnails.\r\n     */\r\n    public get intervalDuration(): number {\r\n        return this._intervalDuration;\r\n    }\r\n\r\n    /**\r\n     * Gets the total number of thumbnails the timeline has been set to display.\r\n     * It depends mainly of the zoom level and the size of the canvas + desired thumbnail one.\r\n     */\r\n    public get totalThumbnails(): number {\r\n        return this._totalThumbnails;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of thumbnails visible in the canvas without scrolling.\r\n     * This is the ideal number when the start time is exactly equivalent to the \r\n     * start of a thumbnail.\r\n     */\r\n    public get visibleThumbnails(): number {\r\n        return this._visibleThumbnails;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a timeline object able to display efficiently a video timeline.\r\n     * @param parent defines the parent of the control. It could be either:\r\n     *   - A canvas element: the canvas we want to render the control in.\r\n     *   - An engine instance: the Babylon.js engine to use to render the control.\r\n     *   - Another Babylon.js control: this allows sharing the engine cross controls to mix and match them for instance.\r\n     * @param options defines the set of options used by the timeline control.\r\n     */\r\n    constructor(parent: BaseControl | Engine | HTMLCanvasElement, options: ITimelineOptions) {\r\n        super(parent);\r\n\r\n        // Default options for the timeline.\r\n        if (options.useClosestThumbnailAsLoadingTexture === undefined) {\r\n            options.useClosestThumbnailAsLoadingTexture = true;\r\n        }\r\n        this._options = options;\r\n\r\n        // Initializes all our\r\n        this._initializeDurations();\r\n        this._initializeTextures();\r\n        this._initializeRenderer();\r\n    }\r\n\r\n    /**\r\n     * Starts rendering the timeline in the canvas.\r\n     * @param callback defines an optional callback that would be run during the RAF.\r\n     */\r\n    public runRenderLoop(callback?: () => void): void {\r\n        this._shouldRender = true;\r\n        // Keep track of the render function to isolate it from potentially other controls\r\n        // Render loops. It helps being able to stop only one of them.\r\n        this._renderFunction = () => {\r\n            this.render(callback);\r\n        };\r\n\r\n        this.engine.runRenderLoop(this._renderFunction);\r\n    }\r\n\r\n    /**\r\n     * Stops rendering the timeline in the canvas.\r\n     */\r\n    public stopRenderLoop(): void {\r\n        this.engine.stopRenderLoop(this._renderFunction);\r\n    }\r\n\r\n    /**\r\n     * Caches one thumbnail for a given time. This can be used to preload thumbnails if needed.\r\n     * @param textureData defines the texture data as a texture, a video, a canvas or a url.\r\n     * @param time defines the time the thumbnail should be used at.\r\n     * @returns the thumbnail texture.\r\n     */\r\n    public addThumbnail(textureData: BaseTexture | HTMLCanvasElement | HTMLVideoElement | string, time: number): BaseTexture {\r\n        // Converts the texture data to an actual babylon.js texture.\r\n        let thumbnail = elementToTexture(this.engine, textureData, \"\" + time);\r\n\r\n        // Store in cache.\r\n        this._thumbnails[time] = thumbnail;\r\n\r\n        return thumbnail;\r\n    }\r\n\r\n    /**\r\n     * Renders the current state of the timeline to the canvas.\r\n     * @param callback defines an optional callback that would be run during the RAF.\r\n     */\r\n    public render(callback?: () => void): void {\r\n        callback && callback();\r\n\r\n        // Prevents useless use of GPU improving efficiency.\r\n        if (!this._shouldRender) {\r\n            return;\r\n        }\r\n\r\n        // Only renders once the loading texture is ready.\r\n        if (!this._loadingThumbnail.isReady()) {\r\n            return;\r\n        }\r\n\r\n        // And the shader has been compiled.\r\n        if (!this._effectWrapper.effect.isReady()) {\r\n            return;\r\n        }\r\n\r\n        // Prevents rendering again if nothing happens.\r\n        this._shouldRender = false;\r\n\r\n        // Set the current shader for rendering.\r\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\r\n\r\n        // Computes which thumbnail should be drawn first on screen.\r\n        const thumbnailIndex = this._currentTime / this._intervalDuration;\r\n        const startTime = Math.floor(thumbnailIndex) * this._intervalDuration;\r\n\r\n        // Renders all the visible thumbnails in the timeline.\r\n        for (let i = 0; i < this._visibleThumbnails + 1; i++) {\r\n            const time = startTime + this._intervalDuration * i;\r\n\r\n            // Set the texture corresponding to the current time.\r\n            const texture = this._getTexture(Math.floor(time));\r\n            this._effectWrapper.effect.setTexture(\"thumbnail\", texture);\r\n\r\n            // Computes the horizontal offset of the thumbnail dynamically by respecting\r\n            // The shader optim defined at the top of the file: \r\n            // shaderOffset = offset * 2. - 1.;\r\n            const widthOffset = (time - this._currentTime) / this._visibleDuration * 2 - 1;\r\n            this._effectWrapper.effect.setFloat2(\"offset\", widthOffset, this._heightOffset);\r\n            this._effectWrapper.effect.setFloat2(\"scale\", this._widthScale, this._heightScale);\r\n\r\n            // Draws the current thumbnail in the canvas as a quad.\r\n            this._effectRenderer.draw();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the current time to display the timeline from.\r\n     * @param time defines the desired time to start from.\r\n     * @returns the clamped current time computed to ensure it fits in the available time range.\r\n     */\r\n    public setCurrentTime(time: number): void {\r\n        // We need to ensure the time respects some boundaries the start of the video\r\n        // and the max settable time to not display empty space on the right.\r\n        this._currentTime = Scalar.Clamp(time, 0, this.maxSettableTime);\r\n        // Re render on next RAF.\r\n        this._shouldRender = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the amount of thumbnails the timeline should contain. It is all of them including the invisible ones due to scrolling.\r\n     * Be carefull, the current time might be impacted to ensure it always starts\r\n     * at the beginning of the displayed thumbnails list.\r\n     * @param totalThumbnails defines the desired number of thumbnails desired.\r\n     * @returns the clamped total thumbnails computed to ensure it fits in the available time range.\r\n     */\r\n    public setTotalThumbnails(totalThumbnails: number): number {\r\n        // We need a round number to not see half a thumbnail on the latest one.\r\n        this._totalThumbnails = Math.floor(totalThumbnails);\r\n        // We also need to ensure it respects some boundaries regarding the min number of thumbnail and the max (equal to the total duration).\r\n        this._totalThumbnails = Scalar.Clamp(this._totalThumbnails, this._visibleThumbnails, this._totalDuration);\r\n\r\n        // We can now compute back the interval of time between thumbnails and the total visible time\r\n        // on screen without scrolling.\r\n        this._intervalDuration = this._totalDuration / this._totalThumbnails;\r\n        this._visibleDuration = this._intervalDuration * this._visibleThumbnails;\r\n\r\n        // Ensures the current time is within the new defined boundaries.\r\n        this.setCurrentTime(this._currentTime);\r\n\r\n        return this._totalThumbnails;\r\n    }\r\n\r\n    /**\r\n     * Sets the amount of time we should see in the timeline as a zoom level in percentage.\r\n     * Be carefull, the current time might be impacted to ensure it always starts\r\n     * at the beginning of the displayed thumbnails list.\r\n     * @param percent defines the desired level of zoom 0% means the entire video is visible without scrolling and 100% the smallest granularity.\r\n     * @returns the clamped total thumbnails computed to ensure it fits in the available time range.\r\n     */\r\n    public setVisibleDurationZoom(percent: number): number {\r\n        // Interpolate the number of thumbnails between the min number and the max\r\n        // based on the given percentage.\r\n        let totalThumbnail = this._visibleThumbnails + (this._totalDuration - this._visibleThumbnails) * percent / 100;\r\n        return this.setTotalThumbnails(totalThumbnail);\r\n    }\r\n\r\n    /**\r\n     * Resizes the timeline to adapt to the new canvas size.\r\n     * The canvas has to be resized before hand.\r\n     * Be carefull, the current time and visible duration might be impacted to ensure it always starts\r\n     * at the beginning of the displayed thumbnails list.\r\n     */\r\n    public resize(): void {\r\n        // Updates engine sizes.\r\n        this.engine.resize();\r\n        // Resets the viewport to the new canvas size.\r\n        this._effectRenderer.setViewport();\r\n        // Initializes the rest of the durations impacted by the canvas size.\r\n        this._initializeCanvasRelativeDurations();\r\n    }\r\n\r\n    /**\r\n     * Dispose all the associated resources with WebGL.\r\n     */\r\n    public dispose(): void {\r\n        // Clear Thumbnails.\r\n        for (let thumbnailIndex in this._thumbnails) {\r\n            if (this._thumbnails.hasOwnProperty(thumbnailIndex)) {\r\n                this._thumbnails[thumbnailIndex].dispose();\r\n            }\r\n        }\r\n\r\n        // Clear the renderer resources.\r\n        this._loadingThumbnail.dispose();\r\n        this._effectWrapper.dispose();\r\n        this._effectRenderer.dispose();\r\n        this._renderFunction = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    private _initializeDurations(): void {\r\n        // Start at 0.\r\n        this._currentTime = 0;\r\n\r\n        // Ensures the provided total duration is meaningful.\r\n        this._totalDuration = Math.max(0, this._options.totalDuration);\r\n        if (this._totalDuration === 0) {\r\n            Logger.Error(\"The total duration can not be 0. Nothing would be displayed.\");\r\n            return;\r\n        }\r\n\r\n        // Initializes the rest of the durations.\r\n        this._initializeCanvasRelativeDurations();\r\n    }\r\n\r\n    private _initializeCanvasRelativeDurations(): void {\r\n        // Compute the max number of thumbnails we can see in the canvas without scrolling.\r\n        // It needs to be an integer for \"UX purpose\".\r\n        this._visibleThumbnails = Math.ceil(this.canvas.clientWidth / this._options.thumbnailWidth);\r\n\r\n        // Compute the scale to apply in the shader for each quads to ensure the\r\n        // number of thumbnails fit in the canvas.\r\n        // Due to shader optim detailled around the vertex shader code, \r\n        // shaderScale = scale * 2.;\r\n        this._widthScale = 1 / this._visibleThumbnails * 2;\r\n\r\n        // Compute the height scale to apply on a thumbnail in the shader\r\n        // in order to respect the provided sizes.\r\n        const ratio = this._options.thumbnailHeight / this._options.thumbnailWidth;\r\n        const effectiveWidth = this.canvas.width / this._visibleThumbnails;\r\n        const effectiveHeight = effectiveWidth * ratio;\r\n        // Due to shader optim detailled around the vertex shader code, \r\n        // shaderScale = scale * 2.;\r\n        this._heightScale = effectiveHeight / this.canvas.height * 2;\r\n\r\n        // Compute a small offset for the height to center the thumbnail in the canvas\r\n        // vertically.\r\n        // The computation should be: (canvasH - effectiveH) / canvasH / 2\r\n        // But due to shader optim detailled around the vertex shader code, \r\n        // shaderOffset = offset * 2. - 1.;\r\n        // shaderOffset = (canvasH - effectiveH) / canvasH - 1\r\n        this._heightOffset = (this.canvas.height - effectiveHeight) / this.canvas.height - 1;\r\n\r\n        // Reinitializes the total number of thumbnails as it might be impacted\r\n        // during a resize.\r\n        this.setTotalThumbnails(this._totalThumbnails || this._visibleThumbnails);\r\n    }\r\n\r\n    private _initializeTextures(): void {\r\n        // Prepares the loading thumbnail.\r\n        this._loadingThumbnail = new Texture(this._options.loadingTextureURI, this.engine, true, true, Constants.TEXTURE_BILINEAR_SAMPLINGMODE);\r\n        // And the thumbnails cache.\r\n        this._thumbnails = { };\r\n    }\r\n\r\n    private _initializeRenderer(): void {\r\n        // Use the smallest module to render a quad on screen (no need for a full scene)\r\n        this._effectRenderer = new EffectRenderer(this.engine, {\r\n            positions: [1, 1, 0, 1, 0, 0, 1, 0],\r\n            indices: [0, 1, 2, 0, 2, 3]\r\n        });\r\n\r\n        // Wraps a shader in a structure known to the Effect Renderer.\r\n        this._effectWrapper = new EffectWrapper({\r\n            engine: this.engine,\r\n            ...ShaderConfiguration\r\n        });\r\n\r\n        // Initializes the viewport to the full canvas size.\r\n        this._effectRenderer.setViewport();\r\n    }\r\n\r\n    private _getTexture(time: number): BaseTexture {\r\n        // Only gets rounded time close to the granularity.\r\n        time = Math.floor(time);\r\n\r\n        // Try grabbing the thumbnail from the cache.\r\n        let thumbnail = this._thumbnails[time];\r\n        if (!thumbnail) {\r\n            // If not creates it from the given callback.\r\n            const textureData = this._options.getThumbnailCallback(time);\r\n            thumbnail = this.addThumbnail(textureData, time);\r\n        }\r\n\r\n        // Returns the thumbnail texture only if ready.\r\n        if (thumbnail.isReady()) {\r\n            return thumbnail;\r\n        }\r\n\r\n        // Else return the loading picture to not block the UI.\r\n        // Render till ready to replace the loading textures by the loaded ones.\r\n        this._shouldRender = true;\r\n\r\n        // Returns the loading thumbnail.\r\n        return this._getLoadingThumbnail(time);\r\n    }\r\n\r\n    private _getLoadingThumbnail(time: number): BaseTexture {\r\n        // Returns loading thumbnail if closest match has been disabled.\r\n        if (!this._options.useClosestThumbnailAsLoadingTexture) {\r\n            return this._loadingThumbnail;\r\n        }\r\n\r\n        // Find the closest available and ready thumbnail.\r\n        const maximumDistance = Math.max(this._totalDuration - time, time);\r\n        for (let i = 1; i <= maximumDistance; i++) {\r\n            const before = time - i;\r\n            if (before > 0) {\r\n                const thumbnail = this._thumbnails[before];\r\n                if (thumbnail && thumbnail.isReady()) {\r\n                    return thumbnail;\r\n                }\r\n            }\r\n\r\n            const after = time + i;\r\n            if (after < this.totalDuration) {\r\n                const thumbnail = this._thumbnails[after];\r\n                if (thumbnail && thumbnail.isReady()) {\r\n                    return thumbnail;\r\n                }\r\n            }\r\n        }\r\n\r\n        // No closest match available:\r\n        return this._loadingThumbnail;\r\n    }\r\n}"]}