{"version":3,"file":"resizer.js","sourceRoot":"","sources":["../../../src/resizer/resizer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { EffectWrapper, EffectRenderer } from \"@babylonjs/core/Materials/effectRenderer\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { Constants } from \"@babylonjs/core/Engines/constants\";\r\n\r\nimport { ShaderConfiguration } from \"./shader\";\r\n\r\nimport { BaseControl } from \"../coreControls/baseControl\";\r\nimport { elementToTexture } from \"../coreControls/elementToTexture\";\r\n\r\n/**\r\n * Represents a resizer control leveraging WebGL to speed up resizing images.\r\n * \r\n * One of the biggest advantage is that the output can directly be used as a \r\n * Babylon.js Texture so that if you need to resize thumbnails,\r\n * they do not need any extra copies a canvas2D would have.\r\n */\r\nexport class Resizer extends BaseControl {\r\n    private _effectRenderer: EffectRenderer;\r\n    private _effectWrapper: EffectWrapper;\r\n\r\n    /**\r\n     * Instantiates a resizer object able to efficiently resize a picture on the GPU.\r\n     * @param parent defines the parent of the control. It could be either:\r\n     *   - A canvas element: the canvas we want to render the control in.\r\n     *   - An engine instance: the Babylon.js engine to use to render the control.\r\n     *   - Another Babylon.js control: this allows sharing the engine cross controls to mix and match them for instance.\r\n     */\r\n    constructor(parent: BaseControl | Engine | HTMLCanvasElement) {\r\n        super(parent);\r\n\r\n        // Initializes the resizer control.\r\n        this._initializeRenderer();\r\n    }\r\n\r\n    /**\r\n     * Dispose all the associated resources with WebGL.\r\n     */\r\n    public dispose(): void {\r\n        // Clear the renderer resources.\r\n        this._effectWrapper.dispose();\r\n        this._effectRenderer.dispose();\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * This will resize the texture to fit in the canvas size.\r\n     * @param input defines the picture input we want to resize. It can be the url of a texture, another canvas or a video element.\r\n     * @returns a promise to know when the rendering is done.\r\n     */\r\n    public resize(textureData: BaseTexture | HTMLCanvasElement | HTMLVideoElement | string): Promise<null> {\r\n        // Converts the texture data to an actual babylon.js texture.\r\n        const inputTexture = elementToTexture(this.engine, textureData, \"input\", true, Constants.TEXTURE_TRILINEAR_SAMPLINGMODE);\r\n\r\n        // Wraps the result in a promise to simplify usage.\r\n        return new Promise((success, _) => {\r\n            const checkIsReady = () => {\r\n                if (inputTexture.isReady()) {\r\n                    // Once the input is ready, Render the texture as a full target quad.\r\n                    this._render(inputTexture);\r\n\r\n                    // Free up memory resources from the input.\r\n                    inputTexture.dispose();\r\n\r\n                    // Notify the promise of the overall completion.\r\n                    success();\r\n                }\r\n                else {\r\n                    // Regularly check the texture status to notify the promise success.\r\n                    setTimeout(() => {\r\n                        checkIsReady();\r\n                    }, 100);\r\n                }\r\n            }\r\n\r\n            checkIsReady();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This will return a Babylon texture resized to a chosen size.\r\n     * @param textureData defines the picture input we want to resize. It can be the url of a texture, another canvas or a video element.\r\n     * @param size defines the The chosen size of the texture on GPU.\r\n     * @returns The Babylon texture to be used in other controls for instance. Be carefull, the texture might not be ready\r\n     * as soon as you get it.\r\n     */\r\n    public getResizedTexture(textureData: BaseTexture | HTMLCanvasElement | HTMLVideoElement | string, size: { width: number, height: number }): BaseTexture {\r\n        // Converts the texture data to an actual babylon.js texture.\r\n        const inputTexture = elementToTexture(this.engine, textureData, \"input\", true, Constants.TEXTURE_TRILINEAR_SAMPLINGMODE);\r\n\r\n        // Creates an offscreen texture to render to.\r\n        const outputTexture = this.engine.createRenderTargetTexture(size, { \r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: false,\r\n            generateStencilBuffer: false,\r\n            samplingMode: Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n         });\r\n         // Ensure it is not ready so far.\r\n         outputTexture.isReady = false;\r\n\r\n        // Simple render function using the effect wrapper as a simple pass through of\r\n        // the input texture. The main difference with the previous function is that it renders\r\n        // to an offscreen texture.\r\n        const render = () => {\r\n            // Sets the output texture.\r\n            this.engine.bindFramebuffer(outputTexture);\r\n\r\n            // Sets the viewport to the render target texture size.\r\n            this._effectRenderer.setViewport();\r\n\r\n            // Render the texture as a full target quad.\r\n            this._render(inputTexture);\r\n\r\n            // Unsets the output texture.\r\n            this.engine.unBindFramebuffer(outputTexture);\r\n\r\n            // Resets the viewport to the canvas size.\r\n            this._effectRenderer.setViewport();\r\n\r\n            // Notify that the texture is ready for consumption.\r\n            outputTexture.isReady = true;\r\n\r\n            // Free up input and output resources.\r\n            this.engine._releaseFramebufferObjects(outputTexture);\r\n            inputTexture.dispose();\r\n        }\r\n\r\n        const checkIsReady = () => {\r\n            if (inputTexture.isReady()) {\r\n                render();\r\n            }\r\n            else {\r\n                setTimeout(() => {\r\n                    checkIsReady();\r\n                }, 100);\r\n            }\r\n        }\r\n        checkIsReady();\r\n\r\n        // Wraps the lower level texture in a more friendly one.\r\n        const texture = new BaseTexture(null);\r\n        texture._texture = outputTexture;\r\n\r\n        return texture;\r\n    }\r\n\r\n    private _render(inputTexture: BaseTexture): void {\r\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\r\n        this._effectWrapper.effect.setTexture(\"toResize\", inputTexture);\r\n        this._effectRenderer.draw();\r\n    }\r\n\r\n    private _initializeRenderer(): void {\r\n        // Use the smallest module to render a quad on screen (no need for a full scene)\r\n        this._effectRenderer = new EffectRenderer(this.engine);\r\n\r\n        // Wraps a shader in a structure known to the Effect Renderer.\r\n        this._effectWrapper = new EffectWrapper({\r\n            engine: this.engine,\r\n            ...ShaderConfiguration\r\n        });\r\n\r\n        // Initializes the viewport to the full canvas size.\r\n        this._effectRenderer.setViewport();\r\n    }\r\n}"]}