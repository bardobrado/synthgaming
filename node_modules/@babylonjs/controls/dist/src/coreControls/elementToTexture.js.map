{"version":3,"file":"elementToTexture.js","sourceRoot":"","sources":["../../../src/coreControls/elementToTexture.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,gDAAgD,CAAC;AAC7E,OAAO,EAAE,OAAO,EAAE,MAAM,4CAA4C,CAAC;AACrE,OAAO,EAAE,kBAAkB,EAAE,MAAM,uDAAuD,CAAC;AAE3F,OAAO,EAAE,SAAS,EAAE,MAAM,mCAAmC,CAAC;AAG9D;;;;;;;;GAQG;AACH,MAAM,UAAU,gBAAgB,CAAC,MAAc,EAC3C,WAAwE,EACxE,IAAY,EACZ,kBAA2B,KAAK,EAChC,gBAAwB,SAAS,CAAC,6BAA6B;IAE/D,IAAI,OAAoB,CAAC;IACzB,mCAAmC;IACnC,IAAI,WAAW,YAAY,WAAW,EAAE;QACpC,OAAO,GAAG,WAAW,CAAC;KACzB;IACD,kDAAkD;SAC7C,IAAI,OAAM,CAAC,WAAW,CAAC,KAAK,QAAQ,EAAE;QACvC,OAAO,GAAG,IAAI,OAAO,CAAC,WAAW,EAAE,MAAM,EAAE,CAAC,eAAe,EAAE,IAAI,EAAE,aAAa,CAAC,CAAC;KACrF;SACI;QACD,mDAAmD;QACnD,MAAM,kBAAkB,GAAG,IAAI,kBAAkB,CAAC,IAAI,EAAE,WAAW,EAAE;YACjE,MAAM,EAAE,MAAM;YACd,eAAe,EAAE,eAAe;YAChC,YAAY,EAAE,aAAa;YAC3B,KAAK,EAAE,IAAI;SACd,CAAC,CAAC;QACH,OAAO,GAAG,kBAAkB,CAAC;QAE7B,MAAM,MAAM,GAAG,GAAG,EAAE;YAChB,kBAAkB,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACjC,kBAAkB,CAAC,OAAO,GAAG,IAAI,CAAC;QACtC,CAAC,CAAC;QAEF,IAAI,WAAW,YAAY,gBAAgB,EAAE;YACzC,IAAI,WAAW,CAAC,UAAU,GAAG,WAAW,CAAC,iBAAiB,EAAE;gBACxD,uCAAuC;gBACvC,yBAAyB;gBACzB,MAAM,SAAS,GAAG,WAAW,CAAC,WAAW,IAAI,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,QAAQ,CAAC;gBACzE,WAAW,CAAC,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,GAAG,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;aAChE;iBACI;gBACD,gDAAgD;gBAChD,MAAM,EAAE,CAAC;aACZ;SACJ;aACI;YACD,qEAAqE;YACrE,MAAM,EAAE,CAAC;SACZ;KACJ;IAED,kCAAkC;IAClC,OAAO,CAAC,KAAK,GAAG,SAAS,CAAC,yBAAyB,CAAC;IACpD,OAAO,CAAC,KAAK,GAAG,SAAS,CAAC,yBAAyB,CAAC;IACpD,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC;IAEpB,OAAO,OAAO,CAAC;AACnB,CAAC","sourcesContent":["import { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { HtmlElementTexture } from \"@babylonjs/core/Materials/Textures/htmlElementTexture\";\r\n\r\nimport { Constants } from \"@babylonjs/core/Engines/constants\";\r\nimport { Engine } from \"@babylonjs/core/Engines/engine\";\r\n\r\n/**\r\n * Converts heterogenous texture types to a Babylon.js usable texture.\r\n * @param engine defines the engine the texture will be associated with.\r\n * @param textureData defines the texture data as a texture, a video, a canvas or a url.\r\n * @param name defines the name of the texture.\r\n * @param generateMipMaps defines if mipmaps needs to be generated for the texture.\r\n * @param textureData defines the type of filtering used for the texture (Constants.TEXTURE_NEAREST_NEAREST...).\r\n * @returns the Babylon.js texture.\r\n */\r\nexport function elementToTexture(engine: Engine,\r\n    textureData: BaseTexture | HTMLCanvasElement | HTMLVideoElement | string, \r\n    name: string,\r\n    generateMipMaps: boolean = false,\r\n    filteringType: number = Constants.TEXTURE_BILINEAR_SAMPLINGMODE): BaseTexture {\r\n\r\n    let texture: BaseTexture;\r\n    // In case of a texture do nothing.\r\n    if (textureData instanceof BaseTexture) {\r\n        texture = textureData;\r\n    }\r\n    // In case of string, load the texture from a URI.\r\n    else if (typeof(textureData) === \"string\") {\r\n        texture = new Texture(textureData, engine, !generateMipMaps, true, filteringType);\r\n    }\r\n    else {\r\n        // Else loads the provided video or canvas element.\r\n        const htmlElementTexture = new HtmlElementTexture(name, textureData, {\r\n            engine: engine,\r\n            generateMipMaps: generateMipMaps,\r\n            samplingMode: filteringType,\r\n            scene: null\r\n        });\r\n        texture = htmlElementTexture;\r\n\r\n        const onload = () => {\r\n            htmlElementTexture.update(false);\r\n            htmlElementTexture.element = null;\r\n        };\r\n\r\n        if (textureData instanceof HTMLVideoElement) {\r\n            if (textureData.readyState < textureData.HAVE_CURRENT_DATA) {\r\n                // Seek to 0 does not raise by default.\r\n                // Use loadedData instead\r\n                const eventName = textureData.currentTime == 0 ? \"loadeddata\" : \"seeked\";\r\n                textureData.addEventListener(eventName, () => { onload(); });\r\n            }\r\n            else {\r\n                // Video Element is ready to be uploaded to GPU.\r\n                onload();\r\n            }\r\n        }\r\n        else {\r\n            // Canvas element are considered already ready to be uploaded to GPU.\r\n            onload();\r\n        }\r\n    }\r\n\r\n    // Sets common texture parameters.\r\n    texture.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture.name = name;\r\n    \r\n    return texture;\r\n}"]}